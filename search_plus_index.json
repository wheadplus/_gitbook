{"./":{"url":"./","title":"介绍","keywords":"","body":"Introduction 背景 前端工作一年。发现一些知识点，不用就会遗忘。等到要用到的时候，总得翻翻MDN、StackOverflow看看别人的文档。想想了，还是得建立自己的知识思维导图才能梳理下学到的知识。所以有了这个博客。 思路 以前学会的有这些: html css js es6 目前在学的： Node.js TypeScript 我会先把旧知识复习下，然后再加上新的知识。大概是每周一篇的思路。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 16:17:57 "},"Html/":{"url":"Html/","title":"HTML","keywords":"","body":"html语义化 背景 在开发过程中，你肯定见过或者自己使用过类似的代码。简单来说就是 一个div写到底。 写的时候挺舒服的，但是当页面结构复杂的时候，命名各有各的习惯。很难直观地看出结构，所以推出了html语义化，让开发人员更规范。 是什么 html语义化就是使用恰当的html标签和class类名让页面结构更清晰。而且方便浏览器识别。 总结就是： 用恰当的标签而不是通篇div 页面结构化 怎么做 举个例子，如下用恰当的标签干恰当的事情，结构化。 article = 独立模块 header = 头部 nav = 导航栏 main = 主要内容 section = 章节 h5 = 标题 p = 段落 figure = 图例 figcaption = 图例的相关说明 aside = 侧边栏 footer = 底部 详细标签查询MDN Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 16:20:26 "},"Css/":{"url":"Css/","title":"CSS","keywords":"","body":"盒模型 css中每个基本元素的内部结构模型就是盒模型。默认content-box结构如下 共有两种盒模型。构成结构分别是： border-box: 内容区=border+padding+content content-box: 内容区=content Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"Css/Center.html":{"url":"Css/Center.html","title":"垂直居中","keywords":"","body":"元素居中 水平居中 行内元素text-aligin .wrapper { text-align:center; } 块级元素margin: 0 auto .content { margin:0 auto; } 垂直居中 绝对定位 .wrapper { position:relative; } .content { position: absolute; top:50%; left:50%; transform: translate(-50%,-50%); } flex .wrapper { display: flex; /* 弹性布局 */ align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */ } 3.行内元素单行居中 注意是单行！ .wrapper { height:40px; line-height: 40px; text-align: center; } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-03 15:43:06 "},"Css/Flex.html":{"url":"Css/Flex.html","title":"Flex","keywords":"","body":"Flex flex 控制块级上下文的弹性排列。主要分父级和子级的使用。 父 水平方向jusity-conent 垂直方向align-items 排列方向flex-direction 是否换行flex-wrap 子 排放顺序，小的前面order 收缩比例 flex-shrink 空间扩展比例 flex-grow 自定义在父级的方向 self-flex Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-03 15:55:17 "},"Css/BFC.html":{"url":"Css/BFC.html","title":"BFC","keywords":"","body":"BFC 块级格式上下文（Block Formatting Context，BFC）是一种规则，它定义了块级元素的渲染规则。 区域内从左到右，不够排列另起一行 区域内相邻的两个div外边距合并 特性 内部的块级元素垂直摆放。 内部的行内元素水平摆放，放不下另起一行。 相邻的两个div，margin合并。 产生条件 html float元素 position absolute 或fixed 行内块级元素 inline-block 更多看mdn Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-03 15:49:00 "},"Css/Selector.html":{"url":"Css/Selector.html","title":"其他","keywords":"","body":"其他 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"Js/":{"url":"Js/","title":"JavaScript","keywords":"","body":"数据类型 JavaScript 中每个值都属于某种数据类型。共有7种： String Number Boolean Null Undefined Object Symbol 其中Object 可以细分为3种： Object Array Function 确定类型 typeof typeof 'sss' \"string\" typeof 123 \"number\" typeof true \"boolean\" typeof null \"object\" typeof undefined \"undefined\" typeof function(){} \"function\" var obj = {name:'jim'} undefined typeof obj //js设计规范如此，逻辑错误 \"object\" typeof [1,2,3] \"object\" var sy = new Symbol(1,2,3) typeof Symbol() \"symbol\" 可以发现 typeof 对于 null Object Array 是无法区分的。 instanceof var o = {}; var a = []; o instanceof Array // false a instanceof Array // true Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-03 16:12:34 "},"Js/ArrayUnique.html":{"url":"Js/ArrayUnique.html","title":"数组去重","keywords":"","body":"数组去重 set去重 ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 然后再转数组，就可以去重 var array = [1,2,1,1,\"1\"] function unique(array) { return Array.from(new Set(array)) } unique(array) //[1,2,\"1\"] 或 function unique(array) { return [...new Set(array)] } 遍历 遍历旧数组，如果新数组内没有旧数组元素就添加，最后返回新数组 function unique(arr) { let result = [] arr.map(el => { if(result.indexOf(el) == -1) { result.push(el) } }) return result } var z = [1,1,1,2,2,2,3,3,3,1,2,3] unique(z) //[1,2,3] 数组降重 就是要把多个层级的数组拍平成一个层级 [1, [2], [3, [[4]]]] //[1,2,3,4] 递归 function flatten(arr) { var newArr = [] function _flat(arr) { arr.forEach(value => { if(Array.isArray(value)) { _flat(value) } else { newArr.push(value) } }) } _flat(arr) return newArr } flatten(arr) // [1, 2, 3, 4] Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-04 10:18:55 "},"Js/Regx.html":{"url":"Js/Regx.html","title":"正则","keywords":"","body":"正则 正则就是计算机语言中一种匹配规则。通过这些规则可以过滤、搜索资源。 创建正则 //构造函数 var reg=new RegExp(']+%>','g'); //字面量 var reg=/]%>/g; 其中，/???/中间代表匹配规则 g 代表修饰符 g: global 全文搜索，不添加的话搜索到第一个结果停止搜索 i: ingore case 忽略大小写，默认大小写敏感 m: multiple lines 多行搜索 不用就忘了的概念 元字符 就是那些特殊符号，回车符。空白符号。常用的： \\r 回车符 \\0 空字符 \\n 换行符 特殊的，平时也不用。用到再百度就OK。 字符类 [] [abcd] //代表匹配abcd中的其中一个， [你要的字符] 取反 ^取反 [^abcd] //代表匹配1个不是a或b或c的字符 范围 -范围 //0-9中的任意一个 var reg1 = /[0123456789]/ //0-9中的任意一个, - 简洁写法 var reg2 = /[0-9]/ //是a-z中的任意一个 var reg3 = /[a-z]/ //大写字母、小写字母、数字中的任意一个 var reg3 = /[a-zA-Z0-9]/ 预定义类 就是预先定义这些代表那些符号，这样写起来就方便。 字符 等价类 含义 . [^\\r\\n] 除了回车符和换行符之外的所有字符 \\d [0-9] 数字字符 \\D [^0-9] 非数字字符 \\s [\\t\\n\\x0B\\f\\r] 空白符 \\S [^\\t\\n\\x0B\\f\\r] 非空白符 \\w [a-zA-Z_0-9] 单词字符，字母、数字下划线 \\W [^a-zA-Z_0-9] 非单词字符 边界 字符 含义 ^ 以xxx开头 $ 以xxx结尾 \\b 单词边界 \\B 非单词边界 var str = 'hello1 world hello2 123456 \\t \\r 哈喽 \\n hello3' // 其中 \\d 数字字符 也就是 0-9 str.match(/hello\\d/g) // [\"hello1\", \"hello2\", \"hello3\"] 匹配hello+数字 str.match(/^hello\\d/g) // [\"hello1\"] 匹配hello开头+数字 str.match(/hello\\d$/g) // [\"hello3\"] 匹配数字结尾 str.match(/\\bhello\\d/g) //[\"hello1\", \"hello2\", \"hello3\"] 匹配单词开头hello+数字 数量词 字符 含义 ? 出现零次或一次（最多出现一次） + 出现一次或多次（至少出现一次） * 出现零次或多次（任意次） {n} 出现n次 {n,m} 出现n到m次 {n,} 至少出现n次 var str = '110' str.match(/\\d{3}/g) //数字出现3此 var str = ‘http://baidu.com’ // . 除了回车符和换行符之外的所有字符 str.match(/https?:\\/\\/.+/) //s出现0次或1次 其他符号出现1次或多次 贪婪模式和非贪婪模式 默认时贪婪模式，也就是尽可能多的匹配，如需要非贪婪模式，只要在量词后面加上?就开启了 \\d表示匹配数字0-9，{3,5}表示3到5次，贪婪模式下5次 '123456789'.match(/\\d{3,5}/g); //[\"12345\", \"6789\"] \\d表示匹配数字0-9，{3,5}表示3到5次，非贪婪模式下3次 '123456789'.match(/\\d{3,5}?/g); //[\"123\", \"456\", \"789\"] // {3,5}? ?非贪婪 或 var str = '叠词可可爱爱，你好恶心心' str.match(/可|爱/g) //[\"可\", \"可\", \"爱\", \"爱\"] 常用正则 判断用户输入的是不是合法的用户名（长度6-20个字符，只能包括字母、数字、下划线）。 var reg = /\\w{6,20}/ 去除字符串两边的空白字符。 function trim(str){ //return str.replace(/^\\s*|\\s*$/g,\"\") return str.replace(/(^\\s*)|(\\s*$)/g, \"\"); //匹配空白开头或空白结尾 * 0-n次 } trim(\" xxx aa bbb \") 总结 正则不用就很容易忘记，也没必要记住。记下来，用到的时候翻一翻，又想起了。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 11:43:05 "},"Js/ajax.html":{"url":"Js/ajax.html","title":"ajax","keywords":"","body":"ajax 是什么? ajax 是 一种技术方案。利用XMLHttpRequest对象，发送http请求和接受http响应。实现页面不刷新情况下与服务器交互数据。 怎么做？ 设置请求地址 监听请求成功事件 发送请求 var request = new XMLHttpRequest() request.open('get','www.baidu.com') request.onreadStateChange = () => { if(request.readState === 4 && requset.status === 200) { console.log(request.responseText) } } request.send() 简化版 var requset = new XMLHttpRequest() request.open('get','www.baicu.com') request.onload(()=> { console.log(request.responseText)}) request.send() axios 添加 npm install axios get请求 axios.get('/user?id=123').then((response)=> { console.log(response) }).catch((error)=>{ console.log(error) })) axios.get('/user', { params: { ID: 12345 } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-03 17:02:27 "},"Js/Environment.html":{"url":"Js/Environment.html","title":"执行环境及作用域","keywords":"","body":"执行环境及作用域 执行环境（简称为环境）是JavaScript中的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定它们各自的行为。每个执行环境都有一个与之相关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。虽然我们无法访问到该对象，但解析器在处理数据时会在后台使用它。 全局执行环境是最外围的一个执行环境。在浏览器中，就是window对象。 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境被推入一个环境栈中。函数执行后，栈将其环境弹出，把控制权返回给之前的执行环境。 作用域链 当代码咋一个环境中执行，会创建·变量对象的一个作用域链。它的作用保证环境的所有变量和函数的有序访问。也就是全局环境执行，执行到函数时，进入下一层环境继续执行。如内部有函数，继续下层执行。每次函数执行后，返回之前的环境中。 var color = 'green' function changeColor() { if(color === 'green') { color = 'red' } else { color = 'blue' } } changeColor() changeColor有的作用域链有两个对象，全局环境和它本身的环境。可以在函数内部访问到变量color，就是因为可以在这个作用域链中找到它。 总结 执行环境保存了它的变量和函数。 函数有它自己的执行环境。 函数执行的时候，先从内部环境找变量 如果找不到，通过作用域链在上层环境中寻找。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-04 09:39:30 "},"Js/Closure.html":{"url":"Js/Closure.html","title":"闭包","keywords":"","body":"闭包 闭包是什么？ 闭包是指有权访问里一个函数作用域链中的变量的函数。-- JavaScript高级程序设计（红皮书） 也就是如果在函数里面可以访问外面的变量，那么这个函数+这些变量 = 闭包。 看看例子： function A(){ var a = 1 function B(){ console.log(a) } return B } var fn = A() fn() //1 fn()就是调用函数A()，函数A()执行了函数B。函数B执行的时候通过作用域链找到变量a。那么函数B和它能访问到的变量a之和就是闭包。 需要注意的是。闭包所保存的是整个变量对象。也就是 {a : 1} 如果a执行过程中发生改变，闭包中的a也改变。 function A(){ var a = 1 function B(){ console.log(a) } a = 3 // 修改 a 值 return B } var fn = A() fn() //3 总结 那闭包的特点呢？ 能函数维持住变量 但是不能维持变量的值 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-04 10:21:12 "},"Js/This.html":{"url":"Js/This.html","title":"this","keywords":"","body":"this this的确定 关于this在红皮书中或MDN中没有明确的定义。 在绝大多数情况下，函数的调用方式决定了this的值。this不能在执行期间被赋值，并且在每次函数被调用时this的值也可能会不同。ES5引入了bind方法来设置函数的this值，而不用考虑函数如何被调用的，ES2015 引入了支持this词法解析的箭头函数（它在闭合的执行环境内设置this的值）。 虽然没有明确定义，但总归有规律可循。这里引用this 的值到底是什么？一次说清楚的方法。因为这样很好记忆。 this 是什么 this就是 call的第一个call参数.需要在它被调用的时候传入的参数才能确定。 显式this 明确给this赋值 fn.call(asThis,1,2) fn.bind(asThis,1,2)() obj.method.call(obj,'hi') 隐式this 没有明确给this赋值的情况下，通过补上call的情况来判断this到底是什么？ fn(1,2) //fn.call(undefined,1,2) 需要看声明fn的环境下，this是什么，全局的话是window obj.method('hi') //obj.method.call(obj,'hi') array[0]('hi') array.[0].call(array,'hi') 测试 button.onclick = function(e){ console.log(this) } // this 是什么？ this 未确定，因为还没被调用。如果用户点击，那么this传入button 如果通过函数调用，如下： var f = button.onclick f() // f.call(undefined) 声明环境全局所以this是window 所以明确this 的步骤 调用没 明确this的pass，不明确的通过call补全去判断 this 测试难度+1 let length = 10 function fn(){console.log(this.length)} let obj = { length: 5, method(fn) { fn() arguments[0]() } } obj.method(fn,1) 分情况讨论。fn fn() // fn.call(undefined) 声明时全局 this.length 等于 window.length length是window的自由属性，所以let length = 10 不会覆盖 window.length 默认window.length == i 返回当前窗口中包含的框架数量(框架包括frame和iframe两种元素). arguments[0]()的情况 arguments[0]() // arguments.0.call(arguments) this 等于arguments // arguments输入时两个参数，所以 arguments.length 等于 2 总结 this 要在调用时才能确定 有传this 不用讨论 没传this 通过补上call确定 fn(1,2) 等价于fn.call(undefined,1,2)需要看声明fn的环境下，this是什么，全局的话是window obj.method('hi') 等价于obj.method.call(obj,'hi') array[0]('hi') 等价于array.[0].call(array,'hi') Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 16:11:41 "},"Js/Throttled.html":{"url":"Js/Throttled.html","title":"函数节流和防抖","keywords":"","body":"函数节流和防抖 节流 在游戏中，技能都有CD机制，也就是cd中不能使用技能。 这种机制也就是节流： function throttle(fn,delay){ let canUse = true return function () { if(!canUse) return canUse = false setTimeout(() => { fn.apply(this, arguments) canUse = true },delay) } } 节流的好处，就是防止用户无效输入给服务端。 常见于底部滚动加载。 防抖 防抖呢，就是触发事件时生成定时器等待，如果定时期间再次触发事件，则重新生成定时器继续等待。如果定时器过去则调用函数。像外卖小哥接了外卖，等待4分种有没有新单子，有就继续接单。没有就派送外卖。 function debounce(fn, delay) { let timerId = null return function() { if(timerId) {window.clearTimeout(timerId)} timerId = setTimeout(() => { fn.apply(this,arguments) timerId = null },delay) } } 防抖常见于用户输入搜索限制。 总结 节流就是CD中，只执行一次函数，防止用户多余输入。 防抖就是外卖小哥送外卖，等待接单，有则继续接单继续等，没有就派单。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 16:39:02 "},"Js/Extend.html":{"url":"Js/Extend.html","title":"继承","keywords":"","body":"继承 继承是指一个对象直接使用另一对象的属性和方法。 在calss语法之前。只能自己实现。方法很多。 所以继承，做了两件事： 得到一个类的属性 得到一个类的方法 属性获取 通过call/apply 绑定属性 function Animal(color) { this.color = color } Animal.prototype.move = function () {} function Dog(color,name) { Animal.call(this,color) Animal.apply(this,arguments)//多个属性时用apply this.name = name } 方法获取 Dog.prototype = Object.create(Animal.prototype) //Object.create(Animal.prototype) 创建一个空对象 空对象.__proto__ 指向Animal //Dog.prototype 通过该空对象获取了animal的方法 注意！Dog.prototype的方法必须在Object.create()之后不然会被覆盖。 然后把constructor指向自己的ok了。 Dog.prototype.constructor = Dog 总结 完整版如下 fuction Animal(color) { this.color = color } Animal.prototype.move = function() {} function Dog(color,name) { //获取属性 Animal.call(this,color) //Animal.apply(this,arguments)多个属性用apply this.name = name } //获取方法 Dog.prototype = Object.create(Animal.prototype) Dog.prototype.constructor = Dog class es6推出class之后就方便了，跟java类似。 class Animal{ constructor(color) { this.color = color } move(){} } class Dog extends Animal { constructor(color,name){ super(color) this.name = name } say() {} } 总结 继承就是要一个类的属性和方法。es6推出class后，使用它继承就可以了。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 16:08:18 "},"Js/Prototype.html":{"url":"Js/Prototype.html","title":"原型和原型链","keywords":"","body":"原型和原型链 原型表示一个类/对象的继承关系。 function Person(name,age) { this.name = 'jim' this.age = age } Person.prototype.sayName = function() { console.log(this.name) } var p1 = new Person() p1.sayName() 通过函数定义了类 Person, 类（函数）自动获取熟悉prototype 每个类的实例如p1都会有个内部属性__proto__ 原型链 原型链就是对象上的__proto__，通过原型链可以获得基础方法。 var str = [1,2,3,4] str.push() .push() 方法就是通过 str.__proto__获取的。通过constructor可以看出它的原型是Array。 .toString则是通过Array.__proto__找到的。 总结 实例通过__proto__获取类上的方法。 可以通过__proto__.constructor可以知道实例的父类 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 16:21:51 "},"Js/CrossDomain.html":{"url":"Js/CrossDomain.html","title":"同源策略&&跨域","keywords":"","body":"同源策略&&跨域 背景 浏览器出于安全方面的考虑，只允许与本域下的接口交互。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。 本域指的是？ 同协议：如都是http或者https 同域名：如都是http://baidu.com/a和http://baidu.com/b 同端口：如都是80端口 举个例子 http://baidu.com/a.js 和 http://baidu.com/b.php 他们是在同源下所以可以正常访问。 不同源的例子： http://baidu.com/main.js 和 https://baidu.com/a.php (协议不同) http://baidu.com/main.js 和 http://bbs.baidu.com/a.php (域名不同，域名必须完全相同才可以) http://baidu.com/main.js 和 http://baidu.com:8080/a.php (端口不同,第一个是80) 但实际使用中，我们有访问不同源下的资源的需求。所以有了下面的几种方法 跨域的方法 JSONP script标签能访问其他域名资源。利用这个特性也能跨域。 访问时提交回调。 当服务器接受到callback回调时，返回你想要的参数。最后在页面接受参数 function showData(ret){ console.log(ret); } 总结流程： 通过script标签在页面提前声明个函数，函数名通过接口传参的方式传给后台 后台解析到函数名后把数据包括在函数名，发送给前端。 缺点 麻烦，每个函数都要处理 前后端都要处理 CORS 跨域资源共享（CORS）是一种白名单机制，通过额外的http header 告诉浏览器，哪些跨域资源可以用。具体需要在后台发送http请求时配置。 res.setHeader('Access-Control-Allow-Origin','http://localhost:8080') //res.setHeader('Access-Control-Allow-Origin','*') 对于需要跨域的域名，放开权限即可。 总结 跨域是为了保护服务器的安全，但设计者也留了通道给服务器访问不同域的资源。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 15:45:44 "},"Advanced/DeepClone.html":{"url":"Advanced/DeepClone.html","title":"手写深拷贝","keywords":"","body":"如何实现深拷贝 首先js的基本类型有 String Number Boolean Null underfnd Object Symbol 深拷贝需要能够复制以上的类型,对于引用类型（Object）也能复制完整对象，而不是只复制引用指针。 JSON序列化反序列化 JSON.parser(JSON.Stringify(xxxx)) 缺点 不支持Function,环，正则，时间等特殊情况。 递归深拷贝 能过复制基础类型的深拷贝 //能过复制基础类型的深拷贝 function deepClone(source) { if (source instanceof Object) { let dist if (source instanceof Array) { dist = new Array() } else if (source instanceof Function) { dist = function () { return source.apply(this, arguments) } } else { dist = new Object() } for (let key in source) { dist[key] = deepClone(source[key]) } return dist } else { // console.log(typeof source, source) return source } } module.exports = deepClone 2.能够复制环、正则、date，过滤原型 //能够复制环、正则、date，过滤原型 //cache全局，会被污染。所以使用对象的方式，把cache单独使用。 let cache = [] function deepClone(source) { if (source instanceof Object) { let cacheDist = findCache(source) if (cacheDist) { //有缓存 return cacheDist } else { //无缓存 let dist if (source instanceof Array) { dist = new Array() } else if (source instanceof Function) { dist = function () { return source.apply(this, arguments) } } else if (source instanceof RegExp) { //source、flags 为 源模式文本和标志 dist = new RegExp(source.source, source.flags) } else if (source instanceof Date) { dist = new Date(source) } else { dist = new Object() } cache.push([source, dist]) //添加到缓存 for (let key in source) { if (source.hasOwnProperty(key)) { // 跳过原型 dist[key] = deepClone(source[key]) } } return dist } } else { // console.log(typeof source, source) return source } } //cache 保存 [source,copy] function findCache(source) { for (let i = 0; i 3.独立缓存，防止cache互相污染。 class DeepCloner { constructor() { this.cache = [] } clone(source) { if (source instanceof Object) { let distCache = this.findCache(source) if (distCache) { return distCache } else { let dist if (source instanceof Array) { dist = new Array() } else if (source instanceof Function) { dist = function () { // arguments 函数参数 ，使用call的话， ...arguments return source.apply(this, arguments) } } else if(source instanceof RegExp) { //.source .flag 为正则的属性 dist = new RegExp(source.source, source.flags) } else if(source instanceof Date) { dist = new Date(source) }else { dist = new Object() } this.cache.push([source, dist]) //push [source, dist] 是为了findCache()比较， for (let key in source) { if (source.hasOwnProperty(key)) { // 跳过原型 dist[key] = this.clone(source[key]) } } return dist } } return source } findCache(source) { for (let i = 0; i 总结 深拷贝的要点： 递归 判断类型 检查环（也叫循环引用） 环 obj.self = obj 需要忽略原型 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 15:36:13 "},"Advanced/Bind.html":{"url":"Advanced/Bind.html","title":"手写bind","keywords":"","body":"手写bind Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"Js/Es6/":{"url":"Js/Es6/","title":"Es6","keywords":"","body":"Es6 ECMAScript 6 新引入了一些语法特性（语法糖），个人觉得主要记住一些语法糖还有重要部分如Promise，不用全记住。其他有需要用到的时候再看看即可。 详细教程 阮一峰es6 MDNes6连接导航-jirengu整理 如果已经懂了概念，直接看阮一峰Es6编程风格，就可以知道语法糖的使用。 这里葫芦依样下，全当总结复习，不做具体验证。 let 和 const let取代var 不存在变量提升 不允许重复声明 const 常量 拥有let的特性 声明后常量,内存地址所保存的数据不得改动 number,字符串、布尔值不能修改 Object 不能修改，但它的属性可以修改。 const animal = {} animal = {name: \"\"} //报错不能修改 Uncaught TypeError: Assignment to constant variable. animal.name = 'jim' //修改属性成功，\"jim\" 结构赋值 let a = 1 let b = 2 let c = 3 //偷懒写法 let [a,b,c] = 1,2,3 let obj = {name: 'jim',age:12} let name = obj.name let age = obj.age //偷懒写法 let {name,age} = obj //默认值 function sayName(name='jim') { return name } sayName() // jim 箭头函数 箭头函数的this就是外层环境的 this，有了它就不用声明_this 来保存this的具体值 let fn = () => { console.log(this) } 数组的扩展 ... let arr = [1,2,3] let arr2 = [...arr] concat()合并成一个新数组 let arr = [1,2,3],arr2 = ['a','b','c'] let arr3 = arr.concat(arr2) //也可以 let arr3 = [...arr,...arr2] Array.from 判断是否数组,成功返回一模一样的数组，否则空数组 Array.from([1, 2, 3]) // [1, 2, 3] Array.from({name:\"jim\"}) //[] Array.from(function fn() {}) //[] find()和findIndex() 找元素和找下表，好用，注意找不到返回值不同即可。 [1,2,3,4,55].find(el => el >2) //3 [1,2,3,4,55].find(el => el >100) //undefined [1,2,3,4,55].findIndex(el => el >2) //2 [1,2,3,4,55].findIndex(el => el >100) //-1 includes表示某个数组是否包含给定的值 [1,2,3,4,55].includes(1) //true [1,2,3,4,55].includes(11) //false 这里只列举了我常用的。详细看ES6-array Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 10:09:28 "},"Js/Es6/Promise.html":{"url":"Js/Es6/Promise.html","title":"Promise","keywords":"","body":"Promise Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。 Promise要解决的问题 function fn1(callback) { setTimeout(()=>{ console.log('fn1') callback() }, 1000) } function fn2(callback) { setTimeout(()=>{ console.log('fn2') callback() }, 1000) } function fn3() { setTimeout(()=>{ console.log('fn3') }, 1000) } fn1(function(){ fn2(function(){ fn3() }) }) 回调地狱， 层层嵌套的接口不清晰。 发生异常难以处理 Promise 基本使用 function AsyncFn() { return new Promise((resolve,reject) => { resolve(//成功返回结果) reject(//失败返回结果) }) } AsyncFn().then(result => { //成功操作 },response => { //失败操作 }).catch(error => { //外层统一处理失败 }).finally( //成功失败都会执行 ) promise的使用 创建Promise实例 成功通过一个参数resolve返回 失败通过第二个参数reject返回 链式调用then(success() ,fail()) .catch()处理异常 .finally()统一处理 栗子： function bigOrSmall() { return new Promise((resolve,reject) => { setTimeout(() => { let result = Math.floor((Math.random()*6)+1) if(result > 3) { resolve(result) } else { reject(result) } },3000) }) } bigOrSmall().then( result => {console.log('大于3，结果: ',result)}, response => {console.log('小于3，结果： ',response)} ).then( result2 => {console.log(\"继续游戏\")}, ()=> {} ).catch( error => {console.log(\"异常错误\")} ).finally( data => { console.log(\"不管输赢，今晚吃夜宵\") }) Promise.all() 控制多个Promise实例的顺序，等所有Promise实例成功才返回。 只有所有实例都失败，Promise.all才会走失败函数。 Promise.all([promise1,promise2]).all(success,fail).catch(error => {}) 栗子 var p1 = new Promise((resolve, reject) => { resolve('resolve p1'); }).then(result => result) .catch(e => e); var p2 = p2 = new Promise((resolve, reject) => { reject('reject p2') }).then(result => result) .catch(e => e); Promise.all([p1, p2]) .then(result => console.log(result)) .catch(e => console.log(e)); // [\"resolve p1\", \"reject p2\"] Promise.race()竞速 控制多个Promise实例的顺序，有 一个Promise实例成功立刻返回， 失败的实例会跳过，等待其他实例。 所有实例都失败，才返回最后一个失败实例 Promise.race([promise1,promise2]).then(success,fail).catch(error => {}) 栗子 var p1 = new Promise((resolve, reject) => { setTimeout(()=>{resolve('3s,resolve p1')},3000) }).then(result => result) .catch(e => e); var p2 = p2 = new Promise((resolve, reject) => { setTimeout(()=>{ reject('2s,reject p2')},4000) }).then(result => result) .catch(e => e); Promise.race([p1, p2]) .then(result => console.log(result)) .catch(e => console.log(e)); // 3s,resolve p1 所有都失败，返回的是最后1个实例的失败数据 var p1 = new Promise((resolve, reject) => { setTimeout(()=>{reject('3s,resolve p1')},3000) }).then(result => result) .catch(e => e); var p2 = p2 = new Promise((resolve, reject) => { setTimeout(()=>{ reject('2s,reject p2')},4000) }).then(result => result) .catch(e => e); undefined Promise.race([p1, p2]) .then(result => console.log(result)) .catch(e => console.log(e)); // 3s,resolve p1 优点 链式结构，避免回调地狱的层层嵌套 缺点 无法取消Promise，一旦新建它就会立即执行，无法中途取消。 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 14:46:37 "},"Js/Es6/Async.html":{"url":"Js/Es6/Async.html","title":"Async","keywords":"","body":"Async 是什么？ async 函数是什么？一句话，它就是 Generator 函数的语法糖。 它和promise一样是异步编程解决方案。区别就是它写成同步代码的格式。 怎么用？ 看下例子 async function timeout(ms) { await new Promise((resolve) => { setTimeout(resolve, ms); }); } async function asyncPrint(value, ms) { await timeout(ms); return value } asyncPrint('hello world', 50).then(result => { console.log(result) }); 处理异常 1.try...catch包裹await async function randonNum() { throw new Error(\"not input\") } async function fn() { try { var result = await randonNum() } catch(e) { console.log(e) } } 2..catch异常处理, async function fn() { return new Promise((resolve,reject) => { reject('error ') }) } async function handleError() { //let result = await fn().then(null,error => {console.log('z',error)}) let result = await fn().catch(error => {console.log('z',error)}) } handleError() z error 总结 async 函数 函数前用async 标志 await后面 处理异步代码，一般是Promise对象，数值直接返回 async 函数返回的是promise对象，所以可以then链继续操作。 异常处理用try...catch 或.catch() 参考 async 阮一峰es6 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 15:31:48 "},"Http/":{"url":"Http/","title":"Http","keywords":"","body":"Http 是什么？ HTTP是一种能够获取如 HTML 这样的网络资源的 protocol(通讯协议)。它是在 Web 上进行数据交换的基础，是一种 client-server 协议，也就是说，请求通常是由像浏览器这样的接受方发起的。一个完整的Web文档通常是由不同的子文档拼接而成的，像是文本、布局描述、图片、视频、脚本等等。 客户端（浏览器）发给服务端的信息 叫做 requests 服务端响应客户端的信息叫做response 有什么用？ 传递数据 控制缓存 开放同源限制（允许资源跨域） 目前我在日常使用过程中，都是通过F12中Network去观察接口请求的状况 提交参数正常否 服务器响应正常否 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 21:47:27 "},"Http/StatusCode.html":{"url":"Http/StatusCode.html","title":"状态码","keywords":"","body":"状态码 http 状态码用来表示浏览器响应的状态。通过状态码可以判断请求成功或失败，具体操作到哪里。 100-199 表示客户端的一些动作 200-199 表示请求成功 300-199 表示需要网络进一步操作 400-199 表示浏览器方面出错 500-199 表示服务器方面出错 状态代码 状态信息 含义 100 Continue 初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新） 101 Switching Protocols 服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1新） 200 OK 一切正常，对GET和POST请求的应答文档跟在后面。 201 Created 服务器已经创建了文档，Location头给出了它的URL。 202 Accepted 已经接受请求，但处理尚未完成。 203 Non-Authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝（HTTP 1.1新）。 204 No Content 没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 205 Reset Content 没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容（HTTP 1.1新）。 206 Partial Content 客户发送了一个带有Range头的GET请求，服务器完成了它（HTTP 1.1新）。 300 Multiple Choices 客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。 301 Moved Permanently 客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。 302 Found 类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。注意，在HTTP1.0中对应的状态信息是“Moved Temporatily”。出现该状态代码时，浏览器能够自动访问新的URL，因此它是一个很有用的状态代码。注意这个状态代码有时候可以和301替换使用。例如，如果浏览器错误地请求http://host/~user（缺少了后面的斜杠），有的服务器 返回301，有的则返回302。严格地说，我们只能假定只有当原来的请求是GET时浏览器才会自动重定向。请参见307。 303 See Other 类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取（HTTP 1.1新）。 304 Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告 诉客户，原来缓冲的文档还可以继续使用。 305 Use Proxy 客户请求的文档应该通过Location头所指明的代理服务器提取（HTTP 1.1新）。 307 Temporary Redirect 和302 （Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是303时才能重定 向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只 能跟随对GET请求的重定向。（HTTP 1.1新） 400 Bad Request 请求出现语法错误。 401 Unauthorized 客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填 写合适的Authorization头后再次发出请求。 403 Forbidden 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。 404 Not Found 无法找到指定位置的资源。这也是一个常用的应答。 405 Method Not Allowed 请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。（HTTP 1.1新） 406 Not Acceptable 指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容（HTTP 1.1新）。 407 Proxy Authentication Required 类似于401，表示客户必须先经过代理服务器的授权。（HTTP 1.1新） 408 Request Timeout 在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。（HTTP 1.1新） 409 Conflict 通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。（HTTP 1.1新） 410 Gone 所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而 404表示由于未知的原因文档不可用。（HTTP 1.1新） 411 Length Required 服务器不能处理请求，除非客户发送一个Content-Length头。（HTTP 1.1新） 412 Precondition Failed 请求头中指定的一些前提条件失败（HTTP 1.1新）。 413 Request Entity Too Large 目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头（HTTP 1.1新）。 414 Request URI Too Long URI太长（HTTP 1.1新）。 416 Requested Range Not Satisfiable 服务器不能满足客户在请求中指定的Range头。（HTTP 1.1新） 500 Internal Server Error 服务器遇到了意料不到的情况，不能完成客户的请求。 501 Not Implemented 服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求。 502 Bad Gateway 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。 503 Service Unavailable 服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个 Retry-After头。 504 Gateway Timeout 由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。（HTTP 1.1新） 505 HTTP Version Not Supported 服务器不支持请求中所指明的HTTP版本。（HTTP 1.1新） 参考 mdn http state code Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 21:54:49 "},"Http/Cache.html":{"url":"Http/Cache.html","title":"缓存","keywords":"","body":"HTTP 缓存有那几种？ 无缓存 每次都要重新请求文件，如果文件大，变更少。很浪费带宽。 缓存 请求资源，把资源缓存在本地，如果调用直接从本地获取。 但是： 节省带宽 如果文件更新，浏览器本地不更新 Expires(过期)（缓存+更新机制） 在缓存的基础上加个(Expires)过期时间,如果时间过期，则重新请求资源。 但是： 缓存可控制 过期时间需对比本地时间 控制单一 CacheControl（缓存+更新机制2.0） 更新机制1.0版本只有 expires,更新机制2.0更多参数。 Cache-Control: max-age=300 Cache-Control: max-stale[=] Cache-Control: min-fresh= Cache-control: no-cache 详细参数说明看MDN 但是还能优化： 如果时间过期了，重新想服务器请求文件，发现文件未修改，则无需更新文件，只需打回消息（文件未更新即可） ETag 更新机制3.0，增加参数ETag,如果ETag未修改则无需更新文件。 Cache-Control: max-age=300； ETag:W/\"e-cbxLFQW5zapn79tQwb/g6Q\" 参考 参考1 参考2 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 21:27:20 "},"Vue/":{"url":"Vue/","title":"Vue","keywords":"","body":"响应式原理 Vue 使用 Object.defineProperty 把data中属性转换为 getter/setter var data = {} undefined var _name = 'jim' //通过Object.defineProperty做了个映射的关系 Object.defineProperty(data,'name',{ get() {return _name}, set(value) { _name = value console.log('更新ui') } }) data.name // jim _name // jim data.name = 'coco' //调用set，这里可以更新ui //更新ui _name // coco 缺点 新增属性没法触发set，也就没有响应式刷新 data.color = 'red' //新增属性没法触发set，也就没有响应式刷新 \"red\" vue提供的解决方法 对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式属性。 Vue.set(vm.someObject, 'b', 2) Vue3.0新方法Proxy Proxy 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。 es6中新增Proxy，使用Proxy代理对象。Proxy能监听到新增属性。 var data = {name:\"jim\"} var dataProxy = new Proxy(data,{ get(target,key) { if(key === 'name') { return data.name } }, set(target,key,value) { data[key] = value console.log(\"更新UI\") } }) dataProxy.name //\"jim\" dataProxy.name = 'coco' //更新UI //新增的color也能监听到 dataProxy.color ='red' // 更新UI 总结 Object.defineProperty把对象转换为getter/setter,当setter更新数据时更新UI 但是它无法监听到新增的属性 Vue可以使用Vue.set(object, propertyName, value) 来新增属性，这样也能响应式更新 Proxy为更好的解决方案 参考 Object.defineProperty Proxy MDN Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 23:09:10 "},"Vue/Component.html":{"url":"Vue/Component.html","title":"组件通信","keywords":"","body":"组件通信 父子组件 父向子 ，通过props传递数据就可以。 子向父，由于vue是单向数据流。这个过程麻烦点。 父组件自定义事件监听儿子传参事件 子组件通过Vue.emit()触发自定义事件change并传递参数。 methods: { emitDataToPapa() { this.$emit('change','data') } } 在父组件处理儿子传参事件 methods: { handleTotal(sonMsg) { console.log(sonMsg) } } 非父子组件通信 使用一个空的Vue实例作为中央事件总线： var bus = new Vue() 在组件A创建监听事件 bus.$on('eventName',function(data){ //触发后的数据操作 }) 触发组件B中的事件，传递参数 bus.$emit('eventName','dataToA') Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 18:04:32 "},"Vue/VueRouter.html":{"url":"Vue/VueRouter.html","title":"VueRouter","keywords":"","body":"VueRouter 就是Vue推出的一个官方路由管理器。 基础使用 //跳转 Home | About //渲染出口 //vue.$route 获取路由参数 vue.$route.query.id //vue.$router 调用路由方法 vue.$router.go() vue.$touter.push() 路由守卫 在路由跳转前后对路由进行操作。 例如将 异常url转移到404页面。 权限限制，当前用户不能访问的跳转404。 打开新页面。 这里只拿beforeEach举例 const router = new VueRouter({.}) router.beforeEach((to,from,next) => { //例如权限限制 }) 目前用到的栗子 router.beforeEach((to, from, next) => { /* 公共路由 */ let commonArray = ['/login', '/home',,'/404']; //登陆时将用户可访问路由添加在本地localStorage，路由跳转前权限限制。 let allRoute = commonArray.concat(JSON.parse(localStorage.getItem('routeArr'))); if (allRoute.contains(to.path)) {/* 是否是公共路由 */ if (to.path == '/onemap') { //特殊页面，特殊处理 window.open('#/onemap', '_blank'); } else { next() } } else { next('/404'); } }) 路由懒加载 可以将异步组件定义为返回一个 Promise 的工厂函数 。 一般vue-cli生成的模板里就有得参考。 const router = new VueRouter({ routes: [ { path: '/foo', component: () => import('./foo.vue') } ] }) 参考 vueRouter官网 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 21:58:11 "},"Vue/VueX.html":{"url":"Vue/VueX.html","title":"VueX","keywords":"","body":"# Vuex 是什么？ Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 也就是官方的状态管理中心。 什么时候要用Vuex？ 中大型应用 需要管理状态 状态太多，eventBus不能满足 概念和怎么用？ State 就是存放基础状态的地方 声明 state 的参数 state: { infos: { age: 18, sex: '女性', firstName: '张', lastName: '三' } }, 在组件中获取state this.$store.state.students Getter 相当于计算属性，对state的过滤或条件限制 getters: { totalName: state => { return state.infos.firstName + state.infos.lastName } }, 在组件中获取Getter computed: { totalName() { return this.$store.getters.totalName } }, Mutation 对state的数据进行操作修改。 mutations: { addAge(state) { state.infos.age++ } }, 在组件中只需调用 Mutation 事件 addAge() { this.$store.commit('addAge') }, 但Mutation 只限于同步函数。异步操作须在Action中使用 Action 对mutation 进行操作m.接受的参数是context，用来出发mutaion actions: { addAgeAction(context) { // context.commit('addAge') //异常操作才使用action，如请求接口后 setTimeout(() => { context.commit('addAge') }, 1000); } }, 调用 Action addAgeAction() { this.$store.dispatch('addAgeAction') } Module Module就是模块，但状态太多的时候，区分不同模块。 const moduleA = { state: { ... }, mutations: { ... }, actions: { ... }, getters: { ... } } const moduleB = { state: { ... }, mutations: { ... }, actions: { ... } } const store = new Vuex.Store({ modules: { a: moduleA, b: moduleB } }) Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 22:07:41 "},"Vue/OtherImportance.html":{"url":"Vue/OtherImportance.html","title":"其他常见问题","keywords":"","body":"其他常见问题 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"MobileDevice/":{"url":"MobileDevice/","title":"移动端","keywords":"","body":"移动端适配 背景（why） 随着手机不断推出，不同屏幕尺寸下网页展示错误成为亟需解决的问题。 一些概念（what） viewport就是屏幕视窗 物理像素(physical pixel) 就是显示设备中一个最微小的物理部件 设备独立像素(density-independent pixel) 代表css像素 设备像素比(device pixel ratio) 也就是dpr 设备像素比 ＝ 物理像素 / 设备独立像素 怎么做？（how） Flexible方案 动态改写标签 给html元素添加data-dpr属性，并且动态改写data-dpr的值 给html元素添加font-size属性，并且动态改写font-size的值 css中使用rem布局，文字保持px var metaEl = doc.createElement('meta'); var scale = isRetina ? 0.5:1; metaEl.setAttribute('name', 'viewport'); metaEl.setAttribute('content', 'initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no'); if (docEl.firstElementChild) { document.documentElement.firstElementChild.appendChild(metaEl); } else { var wrap = doc.createElement('div'); wrap.appendChild(metaEl); documen.write(wrap.innerHTML); } 在vue中使用vw方案 安装插件 cnpm i cssnano cssnano-preset-advanced postcss-aspect-ratio-mini postcss-cssnext postcss-import postcss-px-to-viewport postcss-url postcss-viewport-units postcss-write-svg -D package.json 配置 postcss 设计稿宽高在这里设置 \"postcss\": { \"plugins\": { \"postcss-import\": {}, \"postcss-url\": {}, \"postcss-aspect-ratio-mini\": {}, \"postcss-write-svg\": { \"utf8\": false }, \"postcss-cssnext\": {}, \"postcss-px-to-viewport\": { \"viewportWidth\": 375, \"viewportHeight\": 667, \"unitPrecision\": 3, \"viewportUnit\": \"vw\", \"selectorBlackList\": [ \".ignore\", \".hairlines\" ], \"minPixelValue\": 1, \"mediaQuery\": false }, \"postcss-viewport-units\": {}, \"cssnano\": { \"preset\": \"advanced\", \"autoprefixer\": false, \"postcss-zindex\": false } } }, index.html添加buggyfill（兼容性处理） window.onload = function () { window.viewportUnitsBuggyfill.init({ hacks: window.viewportUnitsBuggyfillHacks }) } 页面还是用px就可以，编译后会转换为vw。100vw 等于设计稿宽度。1vw = 设计稿宽度/100。 不需要转换的地方添加类名.ignore或.hairlines 移动端1px问题 border-image 实现 @svg 1px-border { height: 2px; @rect { fill: var(--color, black); width: 100%; height: 50%; } } .example { border: 1px solid transparent; border-image: svg(1px-border param(--color #00b1ff)) 2 2 stretch; } background-image来实现 @svg square { @rect { fill: var(--color, black); width: 100%; height: 100%; } } #example { background: white svg(square param(--color #00b1ff)); } 总结 meta标签控制网页在移动端的缩放比例 flexible 使用rem布局 随着vw被浏览器更多兼容，以后更多地使用vw去适配移动端 参考 使用Flexible实现手淘H5页面的终端适配 如何在Vue项目中使用vw实现移动端适配 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 15:40:51 "},"Demo/":{"url":"Demo/","title":"demo","keywords":"","body":"demo Drip_UI Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 16:28:49 "}}